<!DOCTYPE html><html class="initial"><head><title>Server.js</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="keywords" content="server, javascript, js, node.js, library, html, html5, express"><meta name="description" content="Flexible and powerful server for Node.js"><link rel="shortcut icon" type="image/png" href="/img/favicon.png?3"><meta property="og:url" content="http://serverjs.io/"><meta property="og:title" content="Server.js"><meta property="og:description" content="Flexible and powerful server for Node.js"><link href="https://unpkg.com/paperdocs@1.0.9/paperdocs.min.css" rel="stylesheet"><link href="/style.css" rel="stylesheet"></head><body class="homepage"><nav class="super"><a class="brand" href="/"><img class="logo" src="/img/split.svg"><span class="text">Server</span></a><input class="show" id="bmenu" type="checkbox"><label class="burger pseudo button switch" for="bmenu"></label><header><strong>Server.js</strong></header><div class="menu" data-headers="h1, h2, h3"><ul class="flex one"></ul></div><footer><div class="flex three"><a class="pseudo button" href="/about">About</a> <a class="pseudo button" href="https://github.com/franciscop/server" target="_blank">Github</a> <a class="button" href="/documentation">Documentation</a></div></footer></nav></body><aside data-headers="h1, h2, h3"><ul></ul></aside><article><h1 id="documentation">Documentation</h1>
<p>To include server, <code>require</code> it as a normal Node package:</p>
<pre><code class="lang-js">const server = require(&#39;server&#39;);
</code></pre>
<h2 id="main-function">Main function</h2>
<p><code>server</code> is a function with this signature:</p>
<pre><code class="lang-js">server(options, middleware1, middleware2, ...);
</code></pre>
<ul>
<li><a href="options.md">Options</a> [optional]: an object with the options. <a href="options.md">Read more...</a>.</li>
<li><a href="middleware.md">Middleware</a> [optional]: the middleware that handles requests <a href="middleware.md">Read more...</a>.</li>
</ul>
<p>However, it also has the handy property:</p>
<ul>
<li><code>server.router</code>: Read the section <a href="router.md">Router</a> to see how it works. This is <strong>not</strong> the default router from express.</li>
</ul>
<h2 id="options">Options</h2>
<p>The first argument of the main function is for setting the options. It can be nothing, a single integer or a plain object:</p>
<pre><code class="lang-js">server();
server(3000);
server({ port: 3000 });  // the same
</code></pre>
<p>As you can guess, internally if it is a single integer it will be converted to the object <code>{ port: ARG }</code>. This is a handy shortcut in case you want the default options except for the port, otherwise you can specify the options (defaults shown here):</p>
<pre><code class="lang-js">server({
  port: 3000,
  public: &#39;./public&#39;,
  viewengine: &#39;pug&#39;,

  middle: {
    // Default middleware options here, see below
  }
});
</code></pre>
<p><strong>Environment variables</strong>: <code>server</code> will value the environment variables higher than the ones you pass explicitly in the function. These can be set through the initial script or by creating a file called <code>.env</code>. They should be uppercase and with a underscore instead of a space:</p>
<pre><code>PORT=3000
VIEW_ENGINE=pug
</code></pre><blockquote>
<p>Don&#39;t forget then to add <code>.env</code> to your <code>.gitignore</code>.</p>
</blockquote>
<p>These are similar to:</p>
<pre><code class="lang-js">server({
  port: 3000,
  &#39;view engine&#39;: &#39;pug&#39;
});
</code></pre>
<p>So this is the inclusion order, from more important to less:</p>
<ol>
<li><code>.env</code>: the variable within the environment.</li>
<li><code>server({ OPTION: 3000 })</code>: the variable set manually when launching the server.</li>
<li><em>defaults</em>: defaults will be used as can be seen below</li>
</ol>
<h3 id="-port-3000-"><code>port</code> : <code>3000</code></h3>
<p>The port where you want to launch the server. Defaults to <code>3000</code> and it&#39;s the only option that can be specified as a single option:</p>
<pre><code class="lang-js">server(3000);
server({ port: 3000 }); // the same
</code></pre>
<p>To set the port in the environment, create a file called <code>.env</code> with this:</p>
<pre><code>PORT=3000
</code></pre><h3 id="-public-public-"><code>public</code> : <code>./public</code></h3>
<p>The folder where your static assets are. This includes images, styles, javascript for the browser, etc. Any file that you want directly accessible through <code>example.com/myfile.pdf</code> should be in this folder. You can set it to any folder within your project.</p>
<p>Through the initialization option:</p>
<pre><code class="lang-js">server({
  public: &#39;./public&#39;
});
</code></pre>
<p>To set the public folder in the environment, create a file called <code>.env</code> with this:</p>
<pre><code>PUBLIC=./public
</code></pre><h3 id="-view-engine-pug-"><code>view engine</code> : <code>pug</code></h3>
<p>The view engine that you want to use to render your templates. <a href="https://pugjs.org/">Read more about pug</a>.</p>
<p>Through the initialization option:</p>
<pre><code class="lang-js">server({
  &#39;view engine&#39;: &#39;pug&#39;
});
</code></pre>
<p>To set the template engine in the environment, create a file called <code>.env</code> with this:</p>
<pre><code>VIEW_ENGINE=./public
</code></pre><h3 id="-secret-undefined-"><code>secret</code> : <code>undefined</code></h3>
<p>This will be inherited by several middleware if they are not set explicitly for the modules. Use a random string here, but it cannot be auto-generated as it has to be the same between restarts from the server. It is also recommended that you <strong>set this up inside <em>.env</em>.</strong> and not as a parameter hardcoded into the code:</p>
<pre><code class="lang-js">// NO (in app.js):
server({ secret: &#39;your-random-string-here&#39; });
</code></pre>
<p>Yes (in <code>.env</code>):</p>
<pre><code>SECRET=your-random-string-here
</code></pre><h2 id="middleware">Middleware</h2>
<p>One of the most powerful things from express and thus from <code>server</code> is the Middleware. We build on this by an evolved concept while giving a wrapper for retro-compatibility:</p>
<pre><code class="lang-js">let setname = s =&gt; s.req.user = &#39;Francisco&#39;;
let sendname = s =&gt; s.res.send(s.req.user);
server(setname, get(&#39;/&#39;, sendname));
</code></pre>
<h3 id="definition">Definition</h3>
<p>A <em>server middleware</em> is a function that will be called on each request. It accepts a server instance and returns a promise for asynchronous methods or anything else for synchronous methods.</p>
<h3 id="parameters">Parameters</h3>
<p>It will only receive a parameter, the current instance of server. This has, among others, the properties <code>req</code> <code>res</code> (similar to express) and <code>options</code>:</p>
<pre><code class="lang-js">let middleware = s =&gt; {
  s.req;      // Request parameter, similar to `(req, res)` in express
  s.res;      // Response parameter, similar to `(req, res)` in express
  s.options;  // The options for the server instance
}
</code></pre>
<p>Then all of the included plugins will be available here. Consult the documentation on each for specifics, but this is how they <em>could</em> be implemented:</p>
<pre><code class="lang-js">let middleware = s =&gt; {
  s.socket;  // A plugin that exports a websocket
  s.db;      // A plugin that exports a database
}
</code></pre>
<p>If you are developing a library or just want more advanced features, you should also have access to these:</p>
<pre><code class="lang-js">let middleware = s =&gt; {
  s.app;     // Current express instance
  s.original;  // The http-server instance
};
</code></pre>
<h4 id="destructuring">Destructuring</h4>
<p>You can and probably should use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">ES7 destructuring</a> right in the function call:</p>
<pre><code class="lang-js">let setname = ({ req }) =&gt; req.user = &#39;Francisco&#39;;
let sendname = ({ req, res }) =&gt; res.send(req.user);
</code></pre>
<p>All of the included plugins will also be available in this way:</p>
<pre><code class="lang-js">let middleware = ({ res, socket, db }) =&gt; {
  db.findAll({ name: &#39;Francisco&#39; }).then(user =&gt; res.json(user));
}
</code></pre>
<h3 id="return-value">Return value</h3>
<p>If your middleware is going to be synchronous, you can just return nothing:</p>
<pre><code class="lang-js">let middle = ({ req }) =&gt; {
  req.body = &#39;Hello world&#39;;
}
</code></pre>
<p>In sync mode you can throw anything to trigger an error:</p>
<pre><code class="lang-js">let middle = ({ req }) =&gt; {
  if (!req.body) {
    throw new Error(&#39;No body provided&#39;);
  }
}
server(middle).catch(err =&gt; {
  console.log(&quot;Expecting body:&quot;, err);
});
</code></pre>
<p>When you want to handle code asynchronously you should return a promise. Then it will continue the middleware chain as it is resolved, or skip it as it is rejected:</p>
<pre><code class="lang-js">let middle = ({ req }) =&gt; new Promise((resolve, reject) =&gt; {
  if (req.body) {
    resolve();
  } else {
    reject(new Error(&#39;No body provided&#39;));
  }
});
</code></pre>
<p>Both the resolve value and the return value get ignored and the same server instance will be passed around. If you want to modify it on your middleware, do it as shown above:</p>
<pre><code class="lang-js">let addsecret = s =&gt; {
  // This will set it by reference
  s.options.secret = &#39;your-random-string-here&#39;;
}
let addsecret = ({ options }) =&gt; {
  // This will also set it by reference
  options.secret = &#39;your-random-string-here&#39;;
}
</code></pre>
<p>// DEPRECATED:</p>
<p>One of the most powerful things from express and thus from <code>server</code> is the Middleware. We extended it by setting some default, useful middleware, but we wanted to also give you the flexibility to edit this.</p>
<blockquote>
<p>We recommend adding your own middleware to a folder in your project called <code>/middle</code>, and all examples below will make this assumption.</p>
</blockquote>
<p>There are four ways of loading middleware with <code>server</code>: as a string, as a function, as an array or as an object. They are all explained below. The most important difference is named (object) vs unnamed (others) middleware, as only named middleware will overwrite the defaults.</p>
<h3 id="string">String</h3>
<p>This is the simplest way to add middleware, it will just require() that string. This is not so useful with some packages since they require an additional function call (such as <code>require(&#39;body-parser&#39;)()</code>), however it&#39;s perfect for your own middleware:</p>
<pre><code class="lang-js">// Load the middleware &#39;body-parser&#39; from the folder &#39;/middle&#39;
server(3000, &#39;./middle/body-parser.js&#39;);
</code></pre>
<p>Then inside that <code>./middle/body-parser.js</code>:</p>
<pre><code class="lang-js">module.exports = function(req, res, next) {

  // do your thing here

  next();
}
</code></pre>
<h3 id="function">Function</h3>
<p>Middleware <em>is</em> a function that accepts <code>(req, res, next)</code> (or <code>(err, req, res, next)</code> parameters, so all other methods are ultimately converted to this one. Read more just by googling&#39; &quot;express middleware&quot; or &quot;write middleware express&quot;.</p>
<p>As a simple example, there are many pre-packaged modules, so let&#39;s see one example where we imagine that <code>body-parser</code> is not loaded by default:</p>
<pre><code class="lang-js">// Include bodyparser in your file
let bodyparser = require(&#39;body-parser&#39;)({ extended: true });

// Load it as middleware
server(3000, bodyparser);
</code></pre>
<h3 id="array">Array</h3>
<p>This will be converted to a series of functions, and inside the array there can be any of the other types. It is useful to bundle them by category:</p>
<pre><code class="lang-js">let parsers = [
  // ...
];

let { get, post } = server.router;
let routes = [
  get(&#39;/&#39;, (req, res) =&gt; { /* ... */ }),
  post(&#39;/&#39;, (req, res) =&gt; { /* ... */ })
];

server(3000, parsers, routes);
</code></pre>
<h3 id="object">Object</h3>
<p>You can name them, and they will <strong>replace one of the default middlewares if the name matches it</strong>. Let&#39;s go with the simple example of <code>body-parser</code>:</p>
<pre><code class="lang-js">const server = require(&#39;server&#39;);

// Uses body-parser
server(3000);

// Don&#39;t use body-parser
server(3000, { bodyparser: false });

// Use a different body-parser
server(3000, { bodyparser: coolerBodyParser() });
</code></pre>
<h2 id="router">Router</h2>
<p>In the end of the day, routes are just a specific kind of middleware. There are many ways of including them, however we recommend these two:</p>
<h3 id="simple-router">Simple router</h3>
<p>To define a simple router, you could do:</p>
<pre><code class="lang-js">const server = require(&#39;server&#39;);

// Import methods &#39;get&#39; and &#39;post&#39; from the router
let { get, post } = server.router;

server(3000,
  get(&#39;/users&#39;, (req, res) =&gt; { /* ... */ }),
  post(&#39;/users&#39;, (req, res) =&gt; { /* ... */ })
);
</code></pre>
<h3 id="complex-router">Complex router</h3>
<p>If you are going to have many routes, we recommend splitting it into a separated file, either in the root of the project as <code>routes.js</code> or in a different place:</p>
<pre><code class="lang-js">// app.js
const server = require(&#39;server&#39;);
let routes = require(&#39;./routes&#39;);

server(3000, routes);
</code></pre>
<pre><code class="lang-js">// routes.js
let { get, post } = require(&#39;server&#39;).router;
let ctrl = require(&#39;auto-load&#39;)(&#39;controllers&#39;);

// You can simply export an array of routes
module.exports = [
  get(&#39;/&#39;, ctrl.home.index),
  get(&#39;/users&#39;, ctrl.users.index),
  post(&#39;/users&#39;, ctrl.users.add),
  get(&#39;/photos&#39;, ctrl.photos.index),
  post(&#39;/photos&#39;, ctrl.photos.add),
  ...
];
</code></pre>
<h3 id="express-router">Express router</h3>
<p>You can also use the express router:</p>
<pre><code class="lang-js">const server = require(&#39;server&#39;);

let router = server.express.Router();
router.get(&#39;/&#39;, home.index);
router.get(&#39;/users&#39;, users.index);
// ...

server({}, router);
</code></pre>
<p>However, we recommend using server&#39;s router whenever possible:</p>
<pre><code class="lang-js">const server = require(&#39;server&#39;);
let { get, post } = server.router;

server({}, [
  get(&#39;/&#39;, home.index),
  get(&#39;/users&#39;, users.index)
]);
</code></pre>
<h3 id="join-routes">Join routes</h3>
<p>If you have two routers and want to make it into one for any reason, you can do so through a helper function we created.</p>
<pre><code class="lang-js">let { get, post, join } = server.router;


let routes = join(
  get(&#39;/&#39;, home.index),
  get(&#39;/users&#39;, users.index),
  // ...
);

server({}, acceptsOnlyASingleRoute(routes));
</code></pre>
<h3 id="experimental">Experimental</h3>
<blockquote>
<p>To enable these, you&#39;ll have to add an <code>EXPERIMENTAL=1</code> to your environment variables. No need to say that this is not stable and not part of the stable API.</p>
</blockquote>
<p>There&#39;s an experimental way of dealing with those:</p>
<pre><code class="lang-js">server({}, [
  get(&#39;/&#39;).send(&#39;Hello 世界&#39;),
  get(&#39;/about.html&#39;).file(&#39;public/about.html&#39;),
  get(&#39;/non-existing&#39;).status(404).send(&#39;Error 404!&#39;)
]);
</code></pre>
<p>They are the same methods as in <a href="http://expressjs.com/en/api.html#res.methods">Express Methods</a> and accept the same parameters (adding <code>file</code>, which is an alias of <code>sendFile</code>, and removing <code>get</code> and <code>set</code> as it conflicts with <code>Router.get</code> and <code>Router.set</code>). The ones that <em>do not send</em> a response can be concatenated, while the ones that send a response will be ignored. So the second <em>send</em> will be ignored:</p>
<pre><code class="lang-js">server({}, [
  get(&#39;/&#39;).status(200).send(&#39;Hi there&#39;).send(&#39;I am ignored&#39;)
]);
</code></pre>
<h3 id="websockets">Websockets</h3>
<blockquote>
<p><em>Not yet available, coming in version 1.1</em></p>
</blockquote>
<pre><code class="lang-js">const server = require(&#39;server&#39;);
let { get, socket } = server.router;

server({}, [
  get(&#39;/&#39;, (req, res) =&gt; res.sendFile(__dirname + &#39;/public/index.html&#39;)),
  socket(&#39;message&#39;, (data, socket, io) =&gt; {
    io.emit(data);
  })
]);
</code></pre>
<h2 id="in-depth">In-depth</h2>
<p>Some extra info if you want to get into some more advanced configuration.</p>
<h3 id="promise">Promise</h3>
<p>The main function returns a promise which will be fulfilled when the server is launched or might throw an initialization error such as port is already in use.</p>
<p>It gets passed an object with these properties:</p>
<ul>
<li><code>app</code>: the express instance</li>
<li><code>original</code>: the original <code>http-server</code></li>
<li><code>express</code>: the express required as in <code>require(&#39;express&#39;)</code></li>
</ul>
<p>Also, it will transparently use the <code>http-server</code> whether possible (through ES6&#39;s Proxy), so function calls such as <code>.close()</code> work straight on the instance:</p>
<pre><code class="lang-js">server().then(server =&gt; {

  // Run the server for a single second then close it
  setTimeout(() =&gt; {
    server.close();
  }, 1000);
}).catch(error =&gt; {
  console.log(&quot;There was an error:&quot;, error);
});
</code></pre>
<p>For most purposes you can just launch the server ignoring the return value:</p>
<pre><code class="lang-js">server();
</code></pre>
<p>This might be useful for error-handling, debugging and testing (see the tests in the folder <code>tests</code>) or extending server&#39;s functionality.</p>
<h3 id="included-modules">Included modules</h3>
<p>This is the default included middleware, which can also be seen in <code>src/modules</code>:</p>
<ul>
<li><a href="https://www.npmjs.com/package/dotenv"><code>dotenv</code></a></li>
<li><code>bodyParser</code> : <a href="https://www.npmjs.com/package/body-parser"><code>body-parser</code></a></li>
<li><code>jsonParser</code> : <a href="https://www.npmjs.com/package/body-parser"><code>body-parser</code></a></li>
<li><code>dataParser</code> : <a href="https://www.npmjs.com/package/express-data-parser"><code>express-data-parser</code></a></li>
<li><code>compress</code> : <a href="https://www.npmjs.com/package/compression"><code>compression</code></a></li>
<li><code>cookieParser</code> : <a href="https://www.npmjs.com/package/cookie-parser"><code>cookie-parser</code></a></li>
<li><code>session</code> : <a href="https://www.npmjs.com/package/express-session"><code>express-session</code></a></li>
<li><code>favicon</code> : <a href="https://www.npmjs.com/package/serve-favicon"><code>serve-favicon</code></a></li>
<li><code>responseTime</code> : <a href="https://www.npmjs.com/package/response-time"><code>response-time</code></a></li>
<li><code>methodOverride</code> : <a href="https://www.npmjs.com/package/method-override"><code>method-override</code></a></li>
</ul>
<p>To modify the options for any of them, pass the option in the <code>middle</code> object:</p>
<pre><code class="lang-js">server({
  middle: {
    dataParser: {
      uploadDir = &quot;public/uploads&quot;
    }
  }
});
</code></pre>
<p>To disable any of those, pass it as a false named value in a middleware:</p>
<pre><code class="lang-js">server(3000, { dataParser: false });
</code></pre>
<p>And to use a different one, pass it as a named middleware:</p>
<pre><code class="lang-js">server(3000, { dataParser: function(req, res, next){ /* ... */ } });
</code></pre>
</article><script>// Replace about.md with #about
[].slice.call(document.querySelectorAll('a')).filter(function(a){
  return /[a-zA-Z0-9\-]+\.md/.test(a.getAttribute('href'));
}).forEach(function(a){
  a.setAttribute('href', '#' + a.getAttribute('href').replace('.md', ''));
});</script><script src="https://unpkg.com/paperdocs@1.0.9/paperdocs.min.js"></script></html>